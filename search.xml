<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[使用高德地图实现点平滑移动 (优化版)]]></title>
      <url>http://yoursite.com/2017/06/06/%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%B9%B3%E6%BB%91%E7%A7%BB%E5%8A%A8(%E4%BC%98%E5%8C%96%E7%89%88)/</url>
      <content type="html"><![CDATA[<p>高德地图中有可供调用的 <strong> 点平滑移动 </strong> 的 API，但是功能相对简单，不足以满足项目需求。<br>故多方寻求方案，未果！只能自己动手实现，现在贴出来和大家一起分享。<br><a id="more"></a></p>
<p><strong> 转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<h3 id="1-原有方案介绍"><a href="#1-原有方案介绍" class="headerlink" title="1. 原有方案介绍"></a>1. 原有方案介绍</h3><p>之前有写过一篇 <a href="http://facex.xyz/2016/12/14/%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%A8%A1%E6%8B%9F%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/" target="_blank" rel="external">使用高德地图模拟运动轨迹</a>, 介绍了使用高德地图的点平滑移动 API 来实现模拟运动轨迹，但是存在几个问题：</p>
<ol>
<li>一旦设置了动画时间并开始动画，只有停止选项，然后就没有然后了。</li>
<li>不支持在轨迹上任意位置暂停，高德 API 的动画只能在<strong>轨迹的经纬度数组中的点</strong>停止，当调用停止动画时，而点还没有到达经纬度数组中的点的位置，这时点会继续向前走（而不是马上停止），直到到达数组中下一个经纬度点上。</li>
<li>不支持以速度来驱动动画，并在动画过程中改变速度。</li>
</ol>
<h3 id="2-优化方案介绍"><a href="#2-优化方案介绍" class="headerlink" title="2. 优化方案介绍"></a>2. 优化方案介绍</h3><p>正对上面的 3 个问题，本次分享的点平滑移动方案优化如下：</p>
<ol>
<li>支持暂停和继续。</li>
<li>支持在任意时刻，任意位置暂停。</li>
<li>支持以速度来驱动动画，并且支持动画中改变速度。</li>
</ol>
<p>下面开始我的分享：</p>
<h3 id="3-高德官方点平滑移动API实现过程"><a href="#3-高德官方点平滑移动API实现过程" class="headerlink" title="3. 高德官方点平滑移动API实现过程"></a>3. 高德官方点平滑移动API实现过程</h3><p>高德地图开源了点平滑移动 API 的技术实现, 我的优化也是建立在此基础之上的。</p>
<blockquote>
<p>开源地址：<a href="https://github.com/amap-demo/android-smooth-move" target="_blank" rel="external">android-smooth-move</a></p>
<p>文档地址：<a href="https://lbs.amap.com/api/android-sdk/guide/draw-on-map/smooth-move" target="_blank" rel="external">点平滑移动</a></p>
</blockquote>
<p>我大概分析下其实现过程：</p>
<ol>
<li>计算轨迹经纬度数组每两个点的距离</li>
<li>然后对每两个点之间的直线路径做 TranslateAnimation 动画，本段动画时间 = 动画总时间 * 本短距离 / 路径总距离</li>
<li>在一段动画结束后开始下一段动画，直到路径结束</li>
</ol>
<p>其实质是对高德 3D 地图做了一个封装，具体的代码实现可以参考源码。</p>
<h3 id="4-优化方案要点讲解"><a href="#4-优化方案要点讲解" class="headerlink" title="4. 优化方案要点讲解"></a>4. 优化方案要点讲解</h3><p>下面是我的优化方案, 只贴部分代码，具体实现细节也请参考源码。</p>
<p><strong>项目地址：<a href="https://github.com/facexxyz/SmoothMove" target="_blank" rel="external">SmoothMove</a></strong></p>
<h4 id="4-1-以速度驱动动画"><a href="#4-1-以速度驱动动画" class="headerlink" title="4.1 以速度驱动动画"></a>4.1 以速度驱动动画</h4><p>在两点之间做 ValueAnimator 时，根据两点之间的距离，计算本次动画需要的时间，本段动画时间 = 本段距离 / 速度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">double</span> dis = eachDistance.poll();</div><div class="line"><span class="keyword">final</span> <span class="keyword">long</span> time = (<span class="keyword">long</span>) (dis / speed * <span class="number">60</span> * <span class="number">60</span>);</div></pre></td></tr></table></figure></p>
<h4 id="4-2-在任意时刻，任意点暂停"><a href="#4-2-在任意时刻，任意点暂停" class="headerlink" title="4.2 在任意时刻，任意点暂停"></a>4.2 在任意时刻，任意点暂停</h4><p>我修改了动画的实现方式，改用 ValueAnimator，通过实现 TypeEvaluator 自定义 LngLatEvaluator 类，使动画过程中返回当前点的经纬度值 LngLat。调用 ValueAnimator 的 cancel() 方法，动画即停止。此时可以取到当前点的坐标点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">LatLng curPos = marker.getPosition();</div><div class="line">nextPos = points.poll();</div><div class="line"><span class="keyword">final</span> LngLat curLngLat = <span class="keyword">new</span> LngLat(curPos.longitude, curPos.latitude);</div><div class="line">LngLat nextLngLat = <span class="keyword">new</span> LngLat(nextPos.longitude, nextPos.latitude);</div><div class="line">markerAnimator = ValueAnimator.ofObject(<span class="keyword">new</span> LngLatEvaluator(), curLngLat,</div><div class="line">        nextLngLat);</div><div class="line">markerAnimator.setDuration(time);</div><div class="line">markerAnimator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</div><div class="line">markerAnimator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</div><div class="line">          <span class="meta">@Override</span></div><div class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</div><div class="line">              LngLat lngLat = (LngLat) animation.getAnimatedValue();</div><div class="line">          &#125;</div><div class="line">      &#125;);</div></pre></td></tr></table></figure>
<h4 id="4-3-暂停和继续"><a href="#4-3-暂停和继续" class="headerlink" title="4.3 暂停和继续"></a>4.3 暂停和继续</h4><p>暂停时先取消当前动画<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pauseMove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (animStop) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    animStop = <span class="keyword">true</span>;</div><div class="line">    markerAnimator.cancel();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在动画取消的回调中重新计算剩余路径的经纬度数组<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(Animator animation)</span> </span>&#123;</div><div class="line">                animCancel = <span class="keyword">true</span>;</div><div class="line">                points.addFirst(nextPos);</div><div class="line">                <span class="keyword">double</span> newDistance = AMapUtils.calculateLineDistance(marker.getPosition(), points.get(<span class="number">0</span>));</div><div class="line">                eachDistance.addFirst(newDistance);</div><div class="line">            &#125;</div></pre></td></tr></table></figure></p>
<p>继续时对重新计算剩余的路径做动画。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resumeMove</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (!animStop) &#123;</div><div class="line">          <span class="keyword">return</span>;</div><div class="line">      &#125;</div><div class="line">      animStop = <span class="keyword">false</span>;</div><div class="line">      startRun();</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<h4 id="4-4-改变平滑移动的速度"><a href="#4-4-改变平滑移动的速度" class="headerlink" title="4.4 改变平滑移动的速度"></a>4.4 改变平滑移动的速度</h4><p>改变平滑移动的速度，需要用到暂停的继续功能，当改变速度时，先暂停当前动画，然后对动画的速度变量赋新值，最后继续动画。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeSpeed</span><span class="params">(<span class="keyword">float</span> speed)</span> </span>&#123;</div><div class="line">    pauseMove();</div><div class="line">    <span class="keyword">this</span>.speed = speed;</div><div class="line">    resumeMove();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="4-5-回调平滑移动的累计移动距离和总距离"><a href="#4-5-回调平滑移动的累计移动距离和总距离" class="headerlink" title="4.5 回调平滑移动的累计移动距离和总距离"></a>4.5 回调平滑移动的累计移动距离和总距离</h4><p>动画中回调平滑移动的累计移动距离和总距离，方便计算当前进度等。</p>
<blockquote>
<p>回调的总距离不等同于路径规划的距离，相对于路径规划距离的不准确性，回调的总距离可视为精确距离(至少对于地图上本次平滑移动)，因为回调的总距离是每两点间距离累加所得。</p>
</blockquote>
<p>大概就这么多了，三言两语也说不清，还是看代码吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[FileProvider（译）]]></title>
      <url>http://yoursite.com/2017/03/04/FileProvider%EF%BC%88%E8%AF%91%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>FileProvider 是 <a href="https://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="external">ContentProvider</a> 的一个特殊子类，通过为一个文件创建一个 <code>content://</code> <a href="https://developer.android.com/reference/android/net/Uri.html" target="_blank" rel="external">Uri</a> 代替 <code>file:///</code> <a href="https://developer.android.com/reference/android/net/Uri.html" target="_blank" rel="external">Uri</a> 在 app 之间安全地共享文件。</p>
<a id="more"></a>
<blockquote>
<ul>
<li>转载请注明出处：<a href="http://www.facex.xyz/2017/03/04/FileProvider（译）" target="_blank" rel="external">http://www.facex.xyz/2017/03/04/FileProvider（译）</a></li>
<li>本文为 Android 官方文档中文翻译，因水平有限，如有翻译不当，望指教。</li>
<li>原文地址： <a href="https://developer.android.com/reference/android/support/v4/content/FileProvider.html" target="_blank" rel="external">FileProvider</a></li>
</ul>
</blockquote>
<p>FileProvider 是 <a href="https://developer.android.com/reference/android/content/ContentProvider.html" target="_blank" rel="external">ContentProvider</a> 的一个特殊子类，通过为一个文件创建一个 <code>content://</code> <a href="https://developer.android.com/reference/android/net/Uri.html" target="_blank" rel="external">Uri</a> 代替 <code>file:///</code> <a href="https://developer.android.com/reference/android/net/Uri.html" target="_blank" rel="external">Uri</a> 在 app 之间安全地共享文件。</p>
<p>一个 content URI 允许你授予使用临时的读写权限去访问文件，当你创建一个包含 content URI 的 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 时，为了向 client app 发送 content URI ，你也可以调用 <a href="https://developer.android.com/reference/android/content/Intent.html#setFlags(int)" target="_blank" rel="external">Intent.setFlags()</a> 来添加权限。只要接收 content URI 的 <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="external">Activity</a> 是活动的，这些权限对 client app 就是可用的。对于一个跳转 <a href="https://developer.android.com/reference/android/app/Service.html" target="_blank" rel="external">Service</a> 的 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a>，只要 <a href="https://developer.android.com/reference/android/app/Service.html" target="_blank" rel="external">Service</a> 是运行的，这些权限就是可用的。</p>
<p>相比之下，为了控制访问一个 file:/// <a href="https://developer.android.com/reference/android/net/Uri.html" target="_blank" rel="external">Uri</a> 你必须修改底层文件的文件系统权限, 这样你提供的这些权限对任何 app 就都是可用的，而且保持有效直到你修改了它们。这个级别的访问从根本上是不安全的。</p>
<p>content URI 提供的更高的访问安全级别使 FileProvider 成为 Android 安全基础设施的关键部分。</p>
<p>FileProvider 概述包含以下几个主题：</p>
<ol>
<li>定义一个 FileProvider</li>
<li>指定可用文件</li>
<li>检索文件的 content URI</li>
<li>授予 URI 临时权限</li>
<li>向其它 App 提供 content URI</li>
</ol>
<h3 id="1-定义一个-FileProvider"><a href="#1-定义一个-FileProvider" class="headerlink" title="1. 定义一个 FileProvider"></a>1. 定义一个 FileProvider</h3><p>由于 FileProvider 的默认功能包含为文件生成 content URI，你不需要在代码中定义一个子类，相反的，你可以通过完全使用 XML 来在你的 app 中包含 FileProvider，通过在你的 app manifest 中添加 <a href="https://developer.android.com/guide/topics/manifest/provider-element.html" target="_blank" rel="external"><provider></provider></a> 元素来指定 FileProvider 组件本身。设置 <code>android:name</code> 属性为 <code>android.support.v4.content.FileProvider</code>，设置 <code>android:authorities</code> 属性为基于你控制的域名的 URI 权限。例如，如果你拥有 mydomain.com 的控制权，你应该使用权限 <code>com.mydomain.fileprovider</code>，设置 <code>android:exported</code> 属性为 <code>false</code>, FileProvider 不需要设置为 public。设置 <a href="https://developer.android.com/guide/topics/manifest/provider-element.html#gprmsn" target="_blank" rel="external">android:grantUriPermissions</a> 为 <code>true</code> 来允许你授予一个文件临时访问。例如：<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></div><div class="line">    ...</div><div class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></div><div class="line">        ...</div><div class="line">        <span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></div><div class="line">            <span class="attr">android:authorities</span>=<span class="string">"com.mydomain.fileprovider"</span></div><div class="line">            <span class="attr">android:exported</span>=<span class="string">"false"</span></div><div class="line">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</div><div class="line">            ...</div><div class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div><div class="line">        ...</div><div class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>如果你想重写任何 FileProvider 方法的默认行为，继承 FileProvider 类，并在 <code>&lt;provider&gt;</code> 元素的 <code>android:name</code> 属性中使用完整 (fully-qualified) 的类名。</p>
<h3 id="2-指定可用的文件"><a href="#2-指定可用的文件" class="headerlink" title="2. 指定可用的文件"></a>2. 指定可用的文件</h3><p>一个 FileProvider 只能为你事先指定的目录下的文件生成一个 content URI。要指定目录，可以在 XML 中使用 <code>&lt;paths&gt;</code> 元素的子元素来指定它的存储区域和路径，例如，以下 <code>paths</code> 元素告诉 FileProvider 你想为你的私人文件区域 <code>images/</code> 的子目录请求 content URIs。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></div><div class="line">    ...</div><div class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p><code>&lt;paths&gt;</code> 元素必须包含一个或多个以下子元素。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>表示你的 app 的内部存储区域 <code>files/</code> 子目录中的文件。这个子目录的地址和 <a href="https://developer.android.com/reference/android/content/Context.html#getFilesDir()" target="_blank" rel="external">Context.getFilesDir()</a> 返回的值一致。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>表示你的 app 的内部存储区域缓存子目录中的文件。这个子目录的根路径的地址和 <a href="https://developer.android.com/reference/android/content/Context.html#getCacheDir()" target="_blank" rel="external">getCacheDir()</a> 返回的值一致。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">external-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>表示外部存储区域跟目录中的文件。这个子目录的根路径的地址和 <a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStorageDirectory()" target="_blank" rel="external">Environment.getExternalStorageDirectory()</a> 返回的值一致。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>表示你的 app 的外部存储区域根目录中的文件。这个子目录的根路径的地址和 <code>Context#getExternalFilesDir(String)</code> <code>Context.getExternalFilesDir(null)</code> 返回的值一致。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">external-cache-path</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">path</span>=<span class="string">"path"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<p>表示你的 app 的外部缓存区域根目录中的文件。这个子目录的根路径的地址和 <a href="https://developer.android.com/reference/android/content/Context.html#getExternalCacheDir()" target="_blank" rel="external">Context.getExternalCacheDir()</a> 返回的值一致。</p>
<p>这些子元素都使用了相同的属性：</p>
<p><code>name=&quot;name&quot;</code></p>
<p>一个 URI 路径片段。为了加强安全性，这个值隐藏了你所共享的子目录的名字。这个值的子目录名字包含在 <code>path</code> 属性中。</p>
<p><code>path=&quot;path&quot;</code></p>
<p>你共享的子目录。虽然 <code>name</code> 属性是一个 URI 路径片段，但是 <code>path</code> 的值才是真正的子目录名子。注意这个值指的是一个 <strong> 子目录 </strong>，不是一个单独的文件。你不能通过它的文件名共享单个的文件，也不能使用通配符指定一个文件子集。<br>你必须为每个包含你想要 content URIs 的文件的目录指定一个 <code>&lt;paths&gt;</code> 子元素, 例如，下面 XML 元素指定两个目录：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images/"</span>/&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_docs"</span> <span class="attr">path</span>=<span class="string">"docs/"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>将 <code>&lt;paths&gt;</code> 元素和它的子元素放入你的项目的 XML 文件中，例如，你可以将它们添加到叫做 <code>res/xml/file_paths.xml</code> 的新文件中。要够链接这个文件到 FileProvider，添加一个 <a href="https://developer.android.com/guide/topics/manifest/meta-data-element.html" target="_blank" rel="external"><meta-data></meta-data></a> 元素作为定义 FileProvider 的 <code>&lt;provider&gt;</code> 元素的子元素。设置 <code>&lt;meta-data&gt;</code> 元素的 “android:name” 属性为 <code>android.support.FILE_PROVIDER_PATHS</code>。设置元素的 “android:resource” 属性为 <code>@xml/file_paths</code>(注意不要指定 <code>.xml</code> 扩展名)。例如：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">provider</span></span></div><div class="line">    <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></div><div class="line">    <span class="attr">android:authorities</span>=<span class="string">"com.mydomain.fileprovider"</span></div><div class="line">    <span class="attr">android:exported</span>=<span class="string">"false"</span></div><div class="line">    <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">meta-data</span></span></div><div class="line">        <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></div><div class="line">        <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</div><div class="line"><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="3-为一个文件生成-Content-URI"><a href="#3-为一个文件生成-Content-URI" class="headerlink" title="3. 为一个文件生成 Content URI"></a>3. 为一个文件生成 Content URI</h3><p>要使用 Content URI 与其它 app 共享文件，你的 app 必须生成一个 Content URI。为了生成一个 Content URI，为这个文件创建一个 <a href="https://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a>，然后将这个 <a href="https://developer.android.com/reference/java/io/File.html" target="_blank" rel="external">File</a> 传入 <a href="https://developer.android.com/reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context,java.lang.String,java.io.File)" target="_blank" rel="external">getUriForFile()</a>，你可以通过 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 发送 <a href="https://developer.android.com/reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context,java.lang.String,java.io.File)" target="_blank" rel="external">getUriForFile()</a> 返回的 Content URI 到其它 app。收到这个 Content URI 的 clent app 可以通过调用 <a href="https://developer.android.com/reference/android/content/ContentResolver.html#openFileDescriptor(android.net.Uri,java.lang.String)" target="_blank" rel="external">ContentResolver.openFileDescriptor</a> 获取的 <a href="https://developer.android.com/reference/android/os/ParcelFileDescriptor.html" target="_blank" rel="external">ParcelFileDescriptor</a> 来打开文件和访问里边的内容。<br>例如，假设你的 app 正在通过 authority 为 <code>com.mydomain.fileprovider</code> 的 FileProvider 为其他 app 提供文件。要获取在内部存储 <code>images/</code> 子目录下的 <code>default_image.jpg</code> 文件的 content URI，添加如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">File imagePath = <span class="keyword">new</span> File(Context.getFilesDir(), <span class="string">"images"</span>);</div><div class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">"default_image.jpg"</span>);</div><div class="line">Uri contentUri = getUriForFile(getContext(), <span class="string">"com.mydomain.fileprovider"</span>, newFile);</div></pre></td></tr></table></figure></p>
<p>作为上一个代码段的结果，<a href="https://developer.android.com/reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context,java.lang.String,java.io.File)" target="_blank" rel="external">getUriForFile()</a> 将返回 content URI <code>content://com.mydomain.fileprovider/my_images/default_image.jpg</code>。</p>
<h3 id="4-授予-URI-临时权限"><a href="#4-授予-URI-临时权限" class="headerlink" title="4. 授予 URI 临时权限"></a>4. 授予 URI 临时权限</h3><p>要给 <a href="https://developer.android.com/reference/android/support/v4/content/FileProvider.html#getUriForFile(android.content.Context,java.lang.String,java.io.File)" target="_blank" rel="external">getUriForFile()</a> 返回的 content URI 授予访问权限，做下面的其中一项：</p>
<ul>
<li>使用期望的 mode flags 调用 <code>content:// Uri</code> 的 <a href="https://developer.android.com/reference/android/content/Context.html#grantUriPermission(java.lang.String,android.net.Uri,int)" target="_blank" rel="external">Context.grantUriPermission(package, Uri, mode_flags)</a> 方法。这将为 content URI 授予指定包的临时访问权限，根据 <code>mode_flags</code> 参数的值，你可以设置 <code>mode_flags</code> 参数的值为 <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_READ_URI_PERMISSION" target="_blank" rel="external">FLAG_GRANT_READ_URI_PERMISSION</a>,<a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_WRITE_URI_PERMISSION" target="_blank" rel="external">FLAG_GRANT_WRITE_URI_PERMISSION</a> 或两者，这个权限将保持有效直到你调用 <a href="https://developer.android.com/reference/android/content/Context.html#revokeUriPermission(android.net.Uri,int)" target="_blank" rel="external">revokeUriPermission()</a> 来撤销它或设备重启。</li>
<li>通过 <a href="https://developer.android.com/reference/android/content/Intent.html#setData(android.net.Uri)" target="_blank" rel="external">setData()</a> 传入 content URI 到 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a>。</li>
<li>下一步，调用 <a href="https://developer.android.com/reference/android/content/Intent.html#setFlags(int)" target="_blank" rel="external">Intent.setFlags()</a> 传入 <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_READ_URI_PERMISSION" target="_blank" rel="external">FLAG_GRANT_READ_URI_PERMISSION</a> 或 <a href="https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_WRITE_URI_PERMISSION" target="_blank" rel="external">FLAG_GRANT_WRITE_URI_PERMISSION</a> 或两者。</li>
<li>最后，发送这个 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 到其它 app。一般你可以通过 <a href="https://developer.android.com/reference/android/app/Activity.html#setResult(int,android.content.Intent)" target="_blank" rel="external">setResult()</a> 来做。</li>
</ul>
<p>只要接收 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 的 <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="external">Activity</a> 的堆栈处于活动状态，Intent 中被授予的权限将保持有效。当堆栈销毁时，权限将自动移除。授予一个 clent app 的任何一个 <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="external">Activity</a> 的权限将自动扩展到这个 app 的其它组件。</p>
<h3 id="5-向其它-App-提供-content-URI"><a href="#5-向其它-App-提供-content-URI" class="headerlink" title="5. 向其它 App 提供 content URI"></a>5. 向其它 App 提供 content URI</h3><p>有很多方法可以向一个 client app 提供 content URI。一个常见的方法是 client app 通过调用 <a href="https://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,int,android.os.Bundle)" target="_blank" rel="external">startActivityResult()</a> 来启动你的 app，<a href="https://developer.android.com/reference/android/app/Activity.html#startActivityForResult(android.content.Intent,int,android.os.Bundle)" target="_blank" rel="external">startActivityResult()</a> 发送一个 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 到你的 app 来启动你的 app 中的一个 <a href="https://developer.android.com/reference/android/app/Activity.html" target="_blank" rel="external">Activity</a>。作为回应，你的 app 可以立即返回一个 content URI 给 clent app 或呈现一个用户界面允许用户选择一个文件。在后一种情况下，一旦用户先择了一个文件，你的 app 可以返回这个文件的 content URI。以上两种情况，你的 app 在通过 <a href="https://developer.android.com/reference/android/app/Activity.html#setResult(int,android.content.Intent)" target="_blank" rel="external">setResult()</a> 发送的 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 中返回 content URI。</p>
<p>你也可以将 content URI 放入 <a href="https://developer.android.com/reference/android/content/ClipData.html" target="_blank" rel="external">ClipData</a> 对象，然后通过调用 <a href="https://developer.android.com/reference/android/content/Intent.html#setClipData(android.content.ClipData)" target="_blank" rel="external">Intent.setClipData()</a> 将这个对象添加到你发送给 client app 的 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 中。通过这种方式，你可以在 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 中添加多个 <a href="https://developer.android.com/reference/android/content/ClipData.html" target="_blank" rel="external">ClipData</a> 对象，每个对象都有自己的 content URI。当你调用 <a href="https://developer.android.com/reference/android/content/Intent.html#setFlags(int)" target="_blank" rel="external">Intent.setFlags()</a> 的 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 来设置临时的访问权限，相同的权限将被应用到所有的 content URIs。</p>
<blockquote>
<p>注意： <a href="https://developer.android.com/reference/android/content/Intent.html#setClipData(android.content.ClipData)" target="_blank" rel="external">Intent.setClipData()</a> 方法只支持 platform version 16 (Android 4.1) 或以上版本，如果你想和之前的版本保持兼容性，你应该每次只在 <a href="https://developer.android.com/reference/android/content/Intent.html" target="_blank" rel="external">Intent</a> 中发送一个 content URI，设置 action 为 <a href="https://developer.android.com/reference/android/content/Intent.html#ACTION_SEND" target="_blank" rel="external">ACTION_SEND</a>，并通过调用 <a href="https://developer.android.com/reference/android/content/Intent.html#setData(android.net.Uri)" target="_blank" rel="external">setData()</a> 将 URI 放入数据中。</p>
</blockquote>
<h3 id="6-更多"><a href="#6-更多" class="headerlink" title="6. 更多"></a>6. 更多</h3><p>要了解有关 FileProvider 的更多信息，请参阅 Android training 课程 <a href="https://developer.android.com/training/secure-file-sharing/index.html" target="_blank" rel="external">Sharing Files Securely with URIs</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git分支管理策略]]></title>
      <url>http://yoursite.com/2017/01/15/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>如果你严肃对待编程，就必定会使用<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html" target="_blank" rel="external">“版本管理系统”</a>（Version Control System）。眼下最流行的”版本管理系统”，非<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>莫属。</p>
<a id="more"></a>
<blockquote>
<p>本文转载自阮一峰老师博客。<br>原文地址：<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
</blockquote>
<p>如果你严肃对待编程，就必定会使用”版本管理系统”（Version Control System）。<br>眼下最流行的”版本管理系统”，非Git莫属。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070501.png" alt=""></p>
<p>相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。<br>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070502.png" alt=""></p>
<p><a href="http://nvie.com/" target="_blank" rel="external">Vincent Driessen</a>提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p>
<h3 id="一、主分支Master"><a href="#一、主分支Master" class="headerlink" title="一、主分支Master"></a>一、主分支Master</h3><p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070503.png" alt=""></p>
<p>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>
<h3 id="二、开发分支Develop"><a href="#二、开发分支Develop" class="headerlink" title="二、开发分支Develop"></a>二、开发分支Develop</h3><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070504.png" alt=""></p>
<p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>
<p>Git创建Develop分支的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b develop master</div></pre></td></tr></table></figure>
<p>将Develop分支发布到Master分支的命令：</p>
<p>切换到Master分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure>
<p>对Develop分支进行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff develop</div></pre></td></tr></table></figure>
<p>这里稍微解释一下，上一条命令的–no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070505.png" alt=""></p>
<p>使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的<a href="http://sandofsky.com/blog/git-workflow.html" target="_blank" rel="external">《Understanding the Git Workflow》</a>。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070506.png" alt=""></p>
<h3 id="三、临时性分支"><a href="#三、临时性分支" class="headerlink" title="三、临时性分支"></a>三、临时性分支</h3><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。<br>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<ul>
<li>功能（feature）分支</li>
<li>预发布（release）分支</li>
<li>修补bug（fixbug）分支</li>
</ul>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
<h3 id="四、功能分支"><a href="#四、功能分支" class="headerlink" title="四、功能分支"></a>四、功能分支</h3><p>接下来，一个个来看这三种”临时性分支”。<br>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070507.png" alt=""></p>
<p>功能分支的名字，可以采用feature-*的形式命名。<br>创建一个功能分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-x develop</div></pre></td></tr></table></figure></p>
<p>开发完成后，将功能分支合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff feature-x</div></pre></td></tr></table></figure></p>
<p>删除feature分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d feature-x</div></pre></td></tr></table></figure></p>
<h3 id="五、预发布分支"><a href="#五、预发布分支" class="headerlink" title="五、预发布分支"></a>五、预发布分支</h3><p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。<br>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。<br>创建一个预发布分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b release-1.2 develop</div></pre></td></tr></table></figure></p>
<p>确认没有问题后，合并到master分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --no-ff release-1.2</div></pre></td></tr></table></figure></p>
<p>对合并生成的新节点，做一个标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a 1.2</div></pre></td></tr></table></figure></p>
<p>再合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff release-1.2</div></pre></td></tr></table></figure></p>
<p>最后，删除预发布分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d release-1.2</div></pre></td></tr></table></figure></p>
<h3 id="六、修补bug分支"><a href="#六、修补bug分支" class="headerlink" title="六、修补bug分支"></a>六、修补bug分支</h3><p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。<br>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070508.png" alt=""></p>
<p>创建一个修补bug分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b fixbug-0.1 master</div></pre></td></tr></table></figure></p>
<p>修补结束后，合并到master分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --no-ff fixbug-0.1</div><div class="line">git tag -a 0.1.1</div></pre></td></tr></table></figure></p>
<p>再合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff fixbug-0.1</div></pre></td></tr></table></figure></p>
<p>最后，删除”修补bug分支”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d fixbug-0.1</div></pre></td></tr></table></figure></p>
<p>　　<br>（完）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你应该知道的BuildConfig]]></title>
      <url>http://yoursite.com/2016/12/26/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84BuildConfig/</url>
      <content type="html"><![CDATA[<p>可能有些人不知道BuildConfig是何物，尤其是初学者，那么试想我们每次编译Release版本时，由于Debug和Relaease环境下配置有所不同，打包前总是要禁用调试Log，修改服务器Host从测试服到正式服等等一系列操作，一般的做法是在编译Release版本前修改相应的配置，开发时再修改回Debug环境。很繁琐有没有？</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<p>在编译时，Android Studio 会生成一个名为 BuildConfig 的类，它包含了一些编译时使用到的常量指。生成的BuildConfig文件内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true|false"</span>);</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_ID = <span class="string">"xyz.facex.demo"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"debug"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLAVOR = <span class="string">""</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_CODE = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_NAME = <span class="string">"1.0"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当编译Debug版本时,BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>当编译Release版本时，BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"false"</span>);</div></pre></td></tr></table></figure></p>
<p>是的，看到这里，我想你应该知道了。</p>
<p>现在我们举个栗子说明下，新建HttpHost类，用来获取服务器Host，我们将BuildConfig类中DEBUG变量赋值给HttpHost的DEBUG，然后我们通过判断HttpHost中DEBUG的值取到相应的Host，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHost</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = BuildConfig.DEBUG;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_TEST = <span class="string">"测试服务器地址"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"正式服务器地址"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据不同版本调用不同的HOST</div><div class="line">     * debug版本返回"测试服务器地址"</div><div class="line">     * release版本返回"正式服务器地址"</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DEBUG ? HOST_TEST : HOST;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照以上代码，我们在发布Release版本时无需修改一行代码，一个字<strong>爽</strong>！</p>
<blockquote>
<p>另外BuildConfig中的变量还支持自定义，有兴趣的可以自行Google。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用高德地图模拟运动轨迹]]></title>
      <url>http://yoursite.com/2016/12/14/%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%A8%A1%E6%8B%9F%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/</url>
      <content type="html"><![CDATA[<p>最近在做一款跑步机的APP，需求是在地图上选定起点和终点，然后根据跑步机上设定的速度模拟用户在地图上沿着起点至终点运动。一般的地图开发，实时位置可通过手机GPS获取，然而本项目用户在跑步机上运动，用户在地图上的位置要根据跑步机设定的速度来模拟。对比了下百度，高德和腾讯地图，冲着高德地图的Demo和文档比较齐全，项目中选定高德地图作为地图开发。<br><a id="more"></a></p>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<ul>
<li><p>意外发现高德3D地图在12月9日更新了<strong>点平滑移动</strong>的api，细看之下非常符合本次需要，感谢高德开发人员，不然有得折腾了！</p>
</li>
<li><p>下文中的<strong>点</strong>指代用户在地图中的位置。</p>
</li>
</ul>
</blockquote>
<p>开撸之前，先上无码图。</p>
<p><img src="http://ohnwilkou.bkt.clouddn.com/SimulateRunning.gif" alt="SimulateRunning"></p>
<h3 id="1-获取轨迹点"><a href="#1-获取轨迹点" class="headerlink" title="1. 获取轨迹点"></a>1. 获取轨迹点</h3><p>首先为简单起见，我事先准备好了起点和终点的经纬度，由于是模拟跑步路径，我选用<strong>步行出行路线规划</strong>获取跑步轨迹。规划成功后我们在onWalkRouteSearched的回调WalkRouteResult中取得轨迹点，只不过返回的轨迹点是一段一段的，为迎合点平滑移动的api，需要每一段的steps合并成一个list。</p>
<h4 id="1-1-规划路径"><a href="#1-1-规划路径" class="headerlink" title="1.1 规划路径"></a>1.1 规划路径</h4><p>根据起点和重点，调用高德api规划路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</div><div class="line">    RouteSearch routeSearch = <span class="keyword">new</span> RouteSearch(<span class="keyword">this</span>);</div><div class="line">    routeSearch.setRouteSearchListener(<span class="keyword">this</span>);</div><div class="line">    RouteSearch.FromAndTo fromAndTo = <span class="keyword">new</span> RouteSearch.FromAndTo(startPoint, endPoint);</div><div class="line">    RouteSearch.WalkRouteQuery query = <span class="keyword">new</span> RouteSearch.WalkRouteQuery(fromAndTo, RouteSearch.WalkDefault);</div><div class="line">    routeSearch.calculateWalkRouteAsyn(query);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-处理回调数据"><a href="#1-2-处理回调数据" class="headerlink" title="1.2 处理回调数据"></a>1.2 处理回调数据</h4><p>取出每一段点得经纬度，合并成一个list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWalkRouteSearched</span><span class="params">(WalkRouteResult walkRouteResult, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    mLatLngs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    mMap.clear();</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">1000</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (walkRouteResult != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths() != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths().size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            WalkPath walkPath = walkRouteResult.getPaths().get(<span class="number">0</span>);</div><div class="line">            mAllDistance = walkPath.getDistance();</div><div class="line">            List&lt;WalkStep&gt; walkSteps = walkPath.getSteps();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; walkSteps.size(); j++) &#123;</div><div class="line">                List&lt;LatLonPoint&gt; latLonPoints = walkSteps.get(j).getPolyline();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; latLonPoints.size(); k++) &#123;</div><div class="line">                    LatLonPoint latLonPoint = latLonPoints.get(k);</div><div class="line">                    mLatLngs.add(<span class="keyword">new</span> LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude()));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 在地图上显示规划路径</div><div class="line">            */</div><div class="line">            addPolylineInPlayGround();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-显示路径"><a href="#2-显示路径" class="headerlink" title="2. 显示路径"></a>2. 显示路径</h3><p>简单地在地图上显示路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPolylineInPlayGround</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;LatLng&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">    mMap.addPolyline(<span class="keyword">new</span> PolylineOptions().addAll(list).width(<span class="number">10</span>).color(Color.RED));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  改变地图视口</div><div class="line">     */</div><div class="line">    LatLngBounds bounds = <span class="keyword">new</span> LatLngBounds(list.get(<span class="number">0</span>), list.get(list.size() - <span class="number">2</span>));</div><div class="line">    mMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, <span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-开始移跑步"><a href="#3-开始移跑步" class="headerlink" title="3. 开始移跑步"></a>3. 开始移跑步</h3><p>用户选择开始跑步时，地图中的点要根据跑步机上设定的速度模拟在地图中运动。根据高德地图<strong>点平滑移动</strong>开发文档，初始化一些数据和设置，开始移动点。高德已经为我们做好了处理，按我们设置的<strong>总移动时间</strong>从起点平滑地移动至终点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mPoints = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">       mSmoothMoveMarker = <span class="keyword">new</span> SmoothMoveMarker(mMap);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的图标</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setDescriptor(BitmapDescriptorFactory.fromResource(R.drawable.ic_navigation_green_a700_24dp));</div><div class="line">       LatLng drivePoint = mPoints.get(<span class="number">0</span>);</div><div class="line">       Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">       mPoints.set(pair.first, drivePoint);</div><div class="line">       List&lt;LatLng&gt; subList = mPoints.subList(pair.first, mPoints.size());</div><div class="line">       <span class="comment">/**</span></div><div class="line">       * 设置滑动的轨迹左边点</div><div class="line">       */</div><div class="line">       mSmoothMoveMarker.setPoints(subList);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的总时间</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mAllDistance / mSpeed));</div><div class="line">       mSmoothMoveMarker.startSmoothMove();</div><div class="line">       mSmoothMoveMarker.setMoveListener(<span class="keyword">new</span> SmoothMoveMarker.MoveListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> v)</span> </span>&#123;</div><div class="line">               <span class="comment">/**</span></div><div class="line">                * 最后一次取到的值即为暂停时的数据，getIndex()方法取到的是当前list的下标,v为剩余距离</div><div class="line">                */</div><div class="line">               mPauseIndex = mSmoothMoveMarker.getIndex();</div><div class="line">               mDistanceRemain = v;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>总移动时间=轨迹长度/运动速度</p>
</blockquote>
<h3 id="4-暂停跑步"><a href="#4-暂停跑步" class="headerlink" title="4. 暂停跑步"></a>4. 暂停跑步</h3><p>用户选择暂停跑步时，我们需要获取到暂停的剩余的轨迹长度和剩余的轨迹点。暂停时的数据已经在上一步取到了，这里只是停止点得移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pauseRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mSmoothMoveMarker.stopMove();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-继续跑步"><a href="#5-继续跑步" class="headerlink" title="5. 继续跑步"></a>5. 继续跑步</h3><p>用户选择选择继续跑步时，我们需要在原先暂停的位置继续移动点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">continueRun</span><span class="params">()</span> </span>&#123;</div><div class="line">        LatLng drivePoint = mPoints.get(mPauseIndex + <span class="number">1</span>);</div><div class="line">        Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">        mPoints.set(pair.first, drivePoint);</div><div class="line">        mPoints = mPoints.subList(pair.first, mPoints.size());</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置剩余的轨迹点</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setPoints(mPoints);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置滑动时间</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mDistanceRemain / mSpeed));</div><div class="line">        mSmoothMoveMarker.startSmoothMove();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="6-结束跑步"><a href="#6-结束跑步" class="headerlink" title="6. 结束跑步"></a>6. 结束跑步</h3><p>当点滑动到达终点时，结束跑步。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>通过以上步骤可以较好的实现需求，以上只是简单的记录实现步骤，具体的细节美化可以按照各自的需求处理。<br>项目Demo：<a href="https://github.com/facexxyz/ImitateRunning。" target="_blank" rel="external">https://github.com/facexxyz/ImitateRunning。</a><br>项目APK:<a href="https://www.pgyer.com/ImitateRunning" target="_blank" rel="external">https://www.pgyer.com/ImitateRunning</a></p>
<blockquote>
<p>参考文献：<a href="http://lbs.amap.com/api/android-sdk/guide/draw-on-map/smooth-move/" target="_blank" rel="external">高德地图点平滑移动api</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>http://yoursite.com/2016/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>项目中遇到这样的一个需求：分别需要对发送的数据和接受的数据做编码和解码处理，且不同的设备编码和解码方式不同。一般写法是根据不同的设备选择相应的编码和解码方式。但是这种方法耦合性高，不易维护，增加设备的支持就需要修改原先的代码，这容易在原本正确的代码中引入新的错误，这也违背了开闭原则。对于这种情况，一种较好的解决方式就是策略模式。</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<p>开闭原则：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
</blockquote>
<h3 id="1-策略模式的定义"><a href="#1-策略模式的定义" class="headerlink" title="1. 策略模式的定义"></a>1. 策略模式的定义</h3><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而存在。</p>
<h3 id="2-策略模式的使用场景"><a href="#2-策略模式的使用场景" class="headerlink" title="2. 策略模式的使用场景"></a>2. 策略模式的使用场景</h3><ul>
<li>针对同一问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。</li>
</ul>
<h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p><img src="http://ohnwilkou.bkt.clouddn.com/pattern_strategy.jpg" alt="策略模式"></p>
<hr>
<h3 id="5-重构步骤"><a href="#5-重构步骤" class="headerlink" title="5. 重构步骤"></a>5. 重构步骤</h3><ol>
<li><p>首先定义设备解码编码策略接口类：DeviceCodecStrategy，类中定义decode和encode两个虚拟方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义设备A编码解码策略实现类：DeviceAStrategy，该类实现DeviceCodecStrategy接口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceAStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备A解码相关方法，这里将需要解码的信息-1</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Author: www.facex.xyz</div><div class="line">         * 设备A编码相关方法，这里将需要解码的信息+1</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义角色类：DeviceCodec</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceCodec</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> DeviceCodecStrategy mStrategy;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DeviceCodecStrategy strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mStrategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.decode(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.encode(data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用策略模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    DeviceCodec deviceCodec = <span class="keyword">new</span> DeviceCodec();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 设置解码编码策略</div><div class="line">     */</div><div class="line">    deviceCodec.setStrategy(<span class="keyword">new</span> DeviceAStrategy());</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A编码后："</span> + deviceCodec.encode(<span class="number">10</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A解码后："</span> + deviceCodec.decode(<span class="number">10</span>));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 输出结果如下，符合预期：</p>
<blockquote>
<p>设备A编码后：11</p>
<p>设备A解码后：9</p>
</blockquote>
</li>
<li><p>现在我们要支持新的DeviceB设备，同DeviceA，定义设备B编码解码策略实现类：DeviceBStrategy，实现DeviceCodecStrategy接口，使用方式同DeviceA。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceBStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B解码相关方法，这里将需要解码的信息-2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B编码相关方法，这里将需要解码的信息+2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>使用策略模式重构代码后，隐藏了编码解码实现，同时可扩展性变强。以后新增加设备只需要实现DeviceCodecStrategy接口，重现decode和encode方法即可，不仅符合了开闭原则，而且逻辑性更强。</p>
<blockquote>
<p>参考文献：《Android源码设计模式解析与实战》</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
