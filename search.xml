<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[你应该知道的BuildConfig]]></title>
      <url>http://yoursite.com/2016/12/26/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84BuildConfig/</url>
      <content type="html"><![CDATA[<p>可能有些人不知道BuildConfig是何物，尤其是初学者，那么试想我们每次编译Release版本时，由于Debug和Relaease环境下配置有所不同，打包前总是要禁用调试Log，修改服务器Host从测试服到正式服等等一系列操作，一般的做法是在编译Release版本前修改相应的配置，开发时再修改回Debug环境。很繁琐有没有？</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<p>在编译时，Android Studio 会生成一个名为 BuildConfig 的类，它包含了一些编译时使用到的常量指。生成的BuildConfig文件内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true|false"</span>);</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_ID = <span class="string">"xyz.facex.demo"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"debug"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLAVOR = <span class="string">""</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_CODE = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_NAME = <span class="string">"1.0"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当编译Debug版本时,BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>当编译Release版本时，BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"false"</span>);</div></pre></td></tr></table></figure></p>
<p>是的，看到这里，我想你应该知道了。</p>
<p>现在我们举个栗子说明下，新建HttpHost类，用来获取服务器Host，我们将BuildConfig类中DEBUG变量赋值给HttpHost的DEBUG，然后我们通过判断HttpHost中DEBUG的值取到相应的Host，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHost</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = BuildConfig.DEBUG;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_TEST = <span class="string">"测试服务器地址"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"正式服务器地址"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据不同版本调用不同的HOST</div><div class="line">     * debug版本返回"测试服务器地址"</div><div class="line">     * release版本返回"正式服务器地址"</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DEBUG ? HOST_TEST : HOST;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照以上代码，我们在发布Release版本时无需修改一行代码，一个字<strong>爽</strong>！</p>
<blockquote>
<p>另外BuildConfig中的变量还支持自定义，有兴趣的可以自行Google。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用高德地图模拟运动轨迹]]></title>
      <url>http://yoursite.com/2016/12/14/%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%A8%A1%E6%8B%9F%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/</url>
      <content type="html"><![CDATA[<p>最近在做一款跑步机的APP，需求是在地图上选定起点和终点，然后根据跑步机上设定的速度模拟用户在地图上沿着起点至终点运动。一般的地图开发，实时位置可通过手机GPS获取，然而本项目用户在跑步机上运动，用户在地图上的位置要根据跑步机设定的速度来模拟。对比了下百度，高德和腾讯地图，冲着高德地图的Demo和文档比较齐全，项目中选定高德地图作为地图开发。<br><a id="more"></a></p>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<ul>
<li><p>意外发现高德3D地图在12月9日更新了<strong>点平滑移动</strong>的api，细看之下非常符合本次需要，感谢高德开发人员，不然有得折腾了！</p>
</li>
<li><p>下文中的<strong>点</strong>指代用户在地图中的位置。</p>
</li>
</ul>
</blockquote>
<p>开撸之前，先上无码图。</p>
<p><img src="http://ohnwilkou.bkt.clouddn.com/SimulateRunning.gif" alt="SimulateRunning"></p>
<h3 id="1-获取轨迹点"><a href="#1-获取轨迹点" class="headerlink" title="1. 获取轨迹点"></a>1. 获取轨迹点</h3><p>首先为简单起见，我事先准备好了起点和终点的经纬度，由于是模拟跑步路径，我选用<strong>步行出行路线规划</strong>获取跑步轨迹。规划成功后我们在onWalkRouteSearched的回调WalkRouteResult中取得轨迹点，只不过返回的轨迹点是一段一段的，为迎合点平滑移动的api，需要每一段的steps合并成一个list。</p>
<h4 id="1-1-规划路径"><a href="#1-1-规划路径" class="headerlink" title="1.1 规划路径"></a>1.1 规划路径</h4><p>根据起点和重点，调用高德api规划路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</div><div class="line">    RouteSearch routeSearch = <span class="keyword">new</span> RouteSearch(<span class="keyword">this</span>);</div><div class="line">    routeSearch.setRouteSearchListener(<span class="keyword">this</span>);</div><div class="line">    RouteSearch.FromAndTo fromAndTo = <span class="keyword">new</span> RouteSearch.FromAndTo(startPoint, endPoint);</div><div class="line">    RouteSearch.WalkRouteQuery query = <span class="keyword">new</span> RouteSearch.WalkRouteQuery(fromAndTo, RouteSearch.WalkDefault);</div><div class="line">    routeSearch.calculateWalkRouteAsyn(query);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-处理回调数据"><a href="#1-2-处理回调数据" class="headerlink" title="1.2 处理回调数据"></a>1.2 处理回调数据</h4><p>取出每一段点得经纬度，合并成一个list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWalkRouteSearched</span><span class="params">(WalkRouteResult walkRouteResult, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    mLatLngs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    mMap.clear();</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">1000</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (walkRouteResult != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths() != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths().size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            WalkPath walkPath = walkRouteResult.getPaths().get(<span class="number">0</span>);</div><div class="line">            mAllDistance = walkPath.getDistance();</div><div class="line">            List&lt;WalkStep&gt; walkSteps = walkPath.getSteps();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; walkSteps.size(); j++) &#123;</div><div class="line">                List&lt;LatLonPoint&gt; latLonPoints = walkSteps.get(j).getPolyline();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; latLonPoints.size(); k++) &#123;</div><div class="line">                    LatLonPoint latLonPoint = latLonPoints.get(k);</div><div class="line">                    mLatLngs.add(<span class="keyword">new</span> LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude()));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 在地图上显示规划路径</div><div class="line">            */</div><div class="line">            addPolylineInPlayGround();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-显示路径"><a href="#2-显示路径" class="headerlink" title="2. 显示路径"></a>2. 显示路径</h3><p>简单地在地图上显示路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPolylineInPlayGround</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;LatLng&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">    mMap.addPolyline(<span class="keyword">new</span> PolylineOptions().addAll(list).width(<span class="number">10</span>).color(Color.RED));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  改变地图视口</div><div class="line">     */</div><div class="line">    LatLngBounds bounds = <span class="keyword">new</span> LatLngBounds(list.get(<span class="number">0</span>), list.get(list.size() - <span class="number">2</span>));</div><div class="line">    mMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, <span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-开始移跑步"><a href="#3-开始移跑步" class="headerlink" title="3. 开始移跑步"></a>3. 开始移跑步</h3><p>用户选择开始跑步时，地图中的点要根据跑步机上设定的速度模拟在地图中运动。根据高德地图<strong>点平滑移动</strong>开发文档，初始化一些数据和设置，开始移动点。高德已经为我们做好了处理，按我们设置的<strong>总移动时间</strong>从起点平滑地移动至终点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mPoints = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">       mSmoothMoveMarker = <span class="keyword">new</span> SmoothMoveMarker(mMap);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的图标</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setDescriptor(BitmapDescriptorFactory.fromResource(R.drawable.ic_navigation_green_a700_24dp));</div><div class="line">       LatLng drivePoint = mPoints.get(<span class="number">0</span>);</div><div class="line">       Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">       mPoints.set(pair.first, drivePoint);</div><div class="line">       List&lt;LatLng&gt; subList = mPoints.subList(pair.first, mPoints.size());</div><div class="line">       <span class="comment">/**</span></div><div class="line">       * 设置滑动的轨迹左边点</div><div class="line">       */</div><div class="line">       mSmoothMoveMarker.setPoints(subList);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的总时间</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mAllDistance / mSpeed));</div><div class="line">       mSmoothMoveMarker.startSmoothMove();</div><div class="line">       mSmoothMoveMarker.setMoveListener(<span class="keyword">new</span> SmoothMoveMarker.MoveListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> v)</span> </span>&#123;</div><div class="line">               <span class="comment">/**</span></div><div class="line">                * 最后一次取到的值即为暂停时的数据，getIndex()方法取到的是当前list的下标,v为剩余距离</div><div class="line">                */</div><div class="line">               mPauseIndex = mSmoothMoveMarker.getIndex();</div><div class="line">               mDistanceRemain = v;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>总移动时间=轨迹长度/运动速度</p>
</blockquote>
<h3 id="4-暂停跑步"><a href="#4-暂停跑步" class="headerlink" title="4. 暂停跑步"></a>4. 暂停跑步</h3><p>用户选择暂停跑步时，我们需要获取到暂停的剩余的轨迹长度和剩余的轨迹点。暂停时的数据已经在上一步取到了，这里只是停止点得移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pauseRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mSmoothMoveMarker.stopMove();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-继续跑步"><a href="#5-继续跑步" class="headerlink" title="5. 继续跑步"></a>5. 继续跑步</h3><p>用户选择选择继续跑步时，我们需要在原先暂停的位置继续移动点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">continueRun</span><span class="params">()</span> </span>&#123;</div><div class="line">        LatLng drivePoint = mPoints.get(mPauseIndex + <span class="number">1</span>);</div><div class="line">        Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">        mPoints.set(pair.first, drivePoint);</div><div class="line">        mPoints = mPoints.subList(pair.first, mPoints.size());</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置剩余的轨迹点</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setPoints(mPoints);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置滑动时间</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mDistanceRemain / mSpeed));</div><div class="line">        mSmoothMoveMarker.startSmoothMove();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="6-结束跑步"><a href="#6-结束跑步" class="headerlink" title="6. 结束跑步"></a>6. 结束跑步</h3><p>当点滑动到达终点时，结束跑步。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>通过以上步骤可以较好的实现需求，以上只是简单的记录实现步骤，具体的细节美化可以按照各自的需求处理。<br>项目Demo：<a href="https://github.com/facexxyz/ImitateRunning。" target="_blank" rel="external">https://github.com/facexxyz/ImitateRunning。</a><br>项目APK:<a href="https://www.pgyer.com/ImitateRunning" target="_blank" rel="external">https://www.pgyer.com/ImitateRunning</a></p>
<blockquote>
<p>参考文献：<a href="http://lbs.amap.com/api/android-sdk/guide/draw-on-map/smooth-move/" target="_blank" rel="external">高德地图点平滑移动api</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>http://yoursite.com/2016/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>项目中遇到这样的一个需求：分别需要对发送的数据和接受的数据做编码和解码处理，且不同的设备编码和解码方式不同。一般写法是根据不同的设备选择相应的编码和解码方式。但是这种方法耦合性高，不易维护，增加设备的支持就需要修改原先的代码，这容易在原本正确的代码中引入新的错误，这也违背了开闭原则。对于这种情况，一种较好的解决方式就是策略模式。</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<p>开闭原则：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
</blockquote>
<h3 id="1-策略模式的定义"><a href="#1-策略模式的定义" class="headerlink" title="1. 策略模式的定义"></a>1. 策略模式的定义</h3><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而存在。</p>
<h3 id="2-策略模式的使用场景"><a href="#2-策略模式的使用场景" class="headerlink" title="2. 策略模式的使用场景"></a>2. 策略模式的使用场景</h3><ul>
<li>针对同一问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。</li>
</ul>
<h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p><img src="http://ohnwilkou.bkt.clouddn.com/pattern_strategy.jpg" alt="策略模式"></p>
<hr>
<h3 id="5-重构步骤"><a href="#5-重构步骤" class="headerlink" title="5. 重构步骤"></a>5. 重构步骤</h3><ol>
<li><p>首先定义设备解码编码策略接口类：DeviceCodecStrategy，类中定义decode和encode两个虚拟方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义设备A编码解码策略实现类：DeviceAStrategy，该类实现DeviceCodecStrategy接口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceAStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备A解码相关方法，这里将需要解码的信息-1</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Author: www.facex.xyz</div><div class="line">         * 设备A编码相关方法，这里将需要解码的信息+1</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义角色类：DeviceCodec</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceCodec</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> DeviceCodecStrategy mStrategy;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DeviceCodecStrategy strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mStrategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.decode(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.encode(data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用策略模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    DeviceCodec deviceCodec = <span class="keyword">new</span> DeviceCodec();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 设置解码编码策略</div><div class="line">     */</div><div class="line">    deviceCodec.setStrategy(<span class="keyword">new</span> DeviceAStrategy());</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A编码后："</span> + deviceCodec.encode(<span class="number">10</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A解码后："</span> + deviceCodec.decode(<span class="number">10</span>));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 输出结果如下，符合预期：</p>
<blockquote>
<p>设备A编码后：11</p>
<p>设备A解码后：9</p>
</blockquote>
</li>
<li><p>现在我们要支持新的DeviceB设备，同DeviceA，定义设备B编码解码策略实现类：DeviceBStrategy，实现DeviceCodecStrategy接口，使用方式同DeviceA。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceBStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B解码相关方法，这里将需要解码的信息-2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B编码相关方法，这里将需要解码的信息+2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>使用策略模式重构代码后，隐藏了编码解码实现，同时可扩展性变强。以后新增加设备只需要实现DeviceCodecStrategy接口，重现decode和encode方法即可，不仅符合了开闭原则，而且逻辑性更强。</p>
<blockquote>
<p>参考文献：《Android源码设计模式解析与实战》</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
