<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Java List对对碰]]></title>
      <url>http://yoursite.com/2017/02/16/Java%20List%E5%AF%B9%E5%AF%B9%E7%A2%B0/</url>
      <content type="html"><![CDATA[<p>Java对两个list集合的数据处理情况非常常见，若处理得当，可大大提高开发效率，本文介绍两个List之间如何做数据处理。</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<h3 id="1-相关方法"><a href="#1-相关方法" class="headerlink" title="1. 相关方法"></a>1. 相关方法</h3><p>文章开始，我们先介绍几个对两个List的数据处理相关的方法，以下解释来自Java官方注释。</p>
<h4 id="1-1-addAll"><a href="#1-1-addAll" class="headerlink" title="1.1 addAll"></a>1.1 addAll</h4><p>Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s iterator (optional operation).</p>
<h4 id="1-2-retainAll"><a href="#1-2-retainAll" class="headerlink" title="1.2 retainAll"></a>1.2 retainAll</h4><p>Retains only the elements in this list that are contained in the specified collection (optional operation).  In other words, removes from this list all of its elements that are not contained in the specified collection.</p>
<h4 id="1-3-removeAll"><a href="#1-3-removeAll" class="headerlink" title="1.3 removeAll"></a>1.3 removeAll</h4><p>Removes from this list all of its elements that are contained in the specified collection (optional operation).</p>
<h4 id="1-4-containsAll"><a href="#1-4-containsAll" class="headerlink" title="1.4 containsAll"></a>1.4 containsAll</h4><p>Returns true if this list contains all of the elements of the specified collection.</p>
<p>此方法可以比较两个List中的数据是否相等。</p>
<h3 id="2-集合"><a href="#2-集合" class="headerlink" title="2. 集合"></a>2. 集合</h3><h4 id="2-1-合集"><a href="#2-1-合集" class="headerlink" title="2.1. 合集"></a>2.1. 合集</h4><p>合集，就是将两个集合的数据合在一起。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list1.add(<span class="string">"A"</span>);</div><div class="line">    list1.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list2.add(<span class="string">"C"</span>);</div><div class="line">    list2.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    list1.retainAll(list2);</div><div class="line">    System.out.println(<span class="string">"合集:"</span> + list1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：并集:[A, B, C, B]</p>
<h4 id="2-2-交集"><a href="#2-2-交集" class="headerlink" title="2.2 交集"></a>2.2 交集</h4><p>交集，就是两个集合的共有元素。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list1.add(<span class="string">"A"</span>);</div><div class="line">    list1.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list2.add(<span class="string">"C"</span>);</div><div class="line">    list2.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    list1.retainAll(list2);</div><div class="line">    System.out.println(<span class="string">"交集:"</span> + list1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：交集:[B]</p>
<h4 id="2-3-差集"><a href="#2-3-差集" class="headerlink" title="2.3 差集"></a>2.3 差集</h4><p>差集，A和B的差集就是属于A但不属于B的数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list1.add(<span class="string">"A"</span>);</div><div class="line">    list1.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list2.add(<span class="string">"C"</span>);</div><div class="line">    list2.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    list1.removeAll(list2);</div><div class="line">    System.out.println(<span class="string">"差集:"</span> + list1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出：差集:[A]</p>
<h4 id="2-4-无重复合集"><a href="#2-4-无重复合集" class="headerlink" title="2.4 无重复合集"></a>2.4 无重复合集</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    List&lt;String&gt; list1 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list1.add(<span class="string">"A"</span>);</div><div class="line">    list1.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> ArrayList&lt;String&gt;();</div><div class="line">    list2.add(<span class="string">"C"</span>);</div><div class="line">    list2.add(<span class="string">"B"</span>);</div><div class="line"></div><div class="line">    list2.removeAll(list1);</div><div class="line">    list1.addAll(list2);</div><div class="line">    System.out.println(<span class="string">"无重复合集:"</span> + list1);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：无重复合集:[A, B, C]</p>
<blockquote>
<p>参考资料：<a href="http://suko.iteye.com/blog/2053654" target="_blank" rel="external">http://suko.iteye.com/blog/2053654</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我常用的Android第三方框架]]></title>
      <url>http://yoursite.com/2017/02/16/%E6%88%91%E5%B8%B8%E7%94%A8%E7%9A%84Android%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/</url>
      <content type="html"><![CDATA[<p>前辈总是说“不要重复造轮子，居然这个问题已经有人很好地解决了，为什么不使用呢？”<br>本文主要记录我在开发中常用的Android第三方开源框架。</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<h3 id="1-Retrofit（网络）"><a href="#1-Retrofit（网络）" class="headerlink" title="1. Retrofit（网络）"></a>1. <a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>（网络）</h3><p>Type-safe HTTP client for Android and Java by Square, Inc.</p>
<h3 id="2-butterknife（视图绑定）"><a href="#2-butterknife（视图绑定）" class="headerlink" title="2. butterknife（视图绑定）"></a>2. <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">butterknife</a>（视图绑定）</h3><p>Bind Android views and callbacks to fields and methods</p>
<h3 id="3-glide（图片加载）"><a href="#3-glide（图片加载）" class="headerlink" title="3. glide（图片加载）"></a>3. <a href="https://github.com/bumptech/glide" target="_blank" rel="external">glide</a>（图片加载）</h3><p>An image loading and caching library for Android focused on smooth scrolling</p>
<h3 id="4-realm-java（数据库）"><a href="#4-realm-java（数据库）" class="headerlink" title="4. realm-java（数据库）"></a>4. <a href="https://github.com/realm/realm-java" target="_blank" rel="external">realm-java</a>（数据库）</h3><p>Realm is a mobile database: a replacement for SQLite &amp; ORMs</p>
<h3 id="5-leakcanary（内存检测）"><a href="#5-leakcanary（内存检测）" class="headerlink" title="5. leakcanary（内存检测）"></a>5. <a href="https://github.com/square/leakcanary" target="_blank" rel="external">leakcanary</a>（内存检测）</h3><p>A memory leak detection library for Android and Java</p>
<h3 id="6-permissionsdispatcher（动态权限）"><a href="#6-permissionsdispatcher（动态权限）" class="headerlink" title="6. permissionsdispatcher（动态权限）"></a>6. <a href="https://github.com/hotchemi/PermissionsDispatcher" target="_blank" rel="external">permissionsdispatcher</a>（动态权限）</h3><p>Provides simple annotation-based API to handle runtime permissions.</p>
<h3 id="7-BaseRecyclerViewAdapterHelper（RecyclerViewAdapter封装）"><a href="#7-BaseRecyclerViewAdapterHelper（RecyclerViewAdapter封装）" class="headerlink" title="7. BaseRecyclerViewAdapterHelper（RecyclerViewAdapter封装）"></a>7. <a href="https://github.com/CymChad/BaseRecyclerViewAdapterHelper" target="_blank" rel="external">BaseRecyclerViewAdapterHelper</a>（RecyclerViewAdapter封装）</h3><p>Powerful and flexible RecyclerAdapter</p>
<h3 id="8-CircleImageView（圆形图片）"><a href="#8-CircleImageView（圆形图片）" class="headerlink" title="8. CircleImageView（圆形图片）"></a>8. <a href="https://github.com/hdodenhof/CircleImageView" target="_blank" rel="external">CircleImageView</a>（圆形图片）</h3><p>A circular ImageView for Android</p>
<h3 id="9-zxing（二维码）"><a href="#9-zxing（二维码）" class="headerlink" title="9. zxing（二维码）"></a>9. <a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing</a>（二维码）</h3><p>ZXing (“zebra crossing”) is an open-source, multi-format 1D/2D barcode image processing library implemented in Java, with ports to other languages.</p>
<h3 id="10-MPAndroidChart（图表）"><a href="#10-MPAndroidChart（图表）" class="headerlink" title="10. MPAndroidChart（图表）"></a>10. <a href="https://github.com/PhilJay/MPAndroidChart" target="_blank" rel="external">MPAndroidChart</a>（图表）</h3><p>A powerful Android chart view / graph view library, supporting line- bar- pie- radar- bubble- and candlestick charts as well as scaling, dragging and animations</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git分支管理策略]]></title>
      <url>http://yoursite.com/2017/01/15/Git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>如果你严肃对待编程，就必定会使用<a href="http://www.ruanyifeng.com/blog/2008/12/a_visual_guide_to_version_control.html" target="_blank" rel="external">“版本管理系统”</a>（Version Control System）。眼下最流行的”版本管理系统”，非<a href="https://git-scm.com/" target="_blank" rel="external">Git</a>莫属。</p>
<a id="more"></a>
<blockquote>
<p>本文转载自阮一峰老师博客。<br>原文地址：<a href="http://www.ruanyifeng.com/blog/2012/07/git.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2012/07/git.html</a></p>
</blockquote>
<p>如果你严肃对待编程，就必定会使用”版本管理系统”（Version Control System）。<br>眼下最流行的”版本管理系统”，非Git莫属。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070501.png" alt=""></p>
<p>相比同类软件，Git有很多优点。其中很显著的一点，就是版本的分支（branch）和合并（merge）十分方便。有些传统的版本管理软件，分支操作实际上会生成一份现有代码的物理拷贝，而Git只生成一个指向当前版本（又称”快照”）的指针，因此非常快捷易用。<br>但是，太方便了也会产生副作用。如果你不加注意，很可能会留下一个枝节蔓生、四处开放的版本库，到处都是分支，完全看不出主干发展的脉络。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070502.png" alt=""></p>
<p><a href="http://nvie.com/" target="_blank" rel="external">Vincent Driessen</a>提出了一个分支管理的策略，我觉得非常值得借鉴。它可以使得版本库的演进保持简洁，主干清晰，各个分支各司其职、井井有条。理论上，这些策略对所有的版本管理系统都适用，Git只是用来举例而已。如果你不熟悉Git，跳过举例部分就可以了。</p>
<h3 id="一、主分支Master"><a href="#一、主分支Master" class="headerlink" title="一、主分支Master"></a>一、主分支Master</h3><p>首先，代码库应该有一个、且仅有一个主分支。所有提供给用户使用的正式版本，都在这个主分支上发布。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070503.png" alt=""></p>
<p>Git主分支的名字，默认叫做Master。它是自动建立的，版本库初始化以后，默认就是在主分支在进行开发。</p>
<h3 id="二、开发分支Develop"><a href="#二、开发分支Develop" class="headerlink" title="二、开发分支Develop"></a>二、开发分支Develop</h3><p>主分支只用来分布重大版本，日常开发应该在另一条分支上完成。我们把开发用的分支，叫做Develop。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070504.png" alt=""></p>
<p>这个分支可以用来生成代码的最新隔夜版本（nightly）。如果想正式对外发布，就在Master分支上，对Develop分支进行”合并”（merge）。</p>
<p>Git创建Develop分支的命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b develop master</div></pre></td></tr></table></figure>
<p>将Develop分支发布到Master分支的命令：</p>
<p>切换到Master分支</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure>
<p>对Develop分支进行合并</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git merge --no-ff develop</div></pre></td></tr></table></figure>
<p>这里稍微解释一下，上一条命令的–no-ff参数是什么意思。默认情况下，Git执行”快进式合并”（fast-farward merge），会直接将Master分支指向Develop分支。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070505.png" alt=""></p>
<p>使用–no-ff参数后，会执行正常合并，在Master分支上生成一个新节点。为了保证版本演进的清晰，我们希望采用这种做法。关于合并的更多解释，请参考Benjamin Sandofsky的<a href="http://sandofsky.com/blog/git-workflow.html" target="_blank" rel="external">《Understanding the Git Workflow》</a>。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070506.png" alt=""></p>
<h3 id="三、临时性分支"><a href="#三、临时性分支" class="headerlink" title="三、临时性分支"></a>三、临时性分支</h3><p>前面讲到版本库的两条主要分支：Master和Develop。前者用于正式发布，后者用于日常开发。其实，常设分支只需要这两条就够了，不需要其他了。<br>但是，除了常设分支以外，还有一些临时性分支，用于应对一些特定目的的版本开发。临时性分支主要有三种：</p>
<ul>
<li>功能（feature）分支</li>
<li>预发布（release）分支</li>
<li>修补bug（fixbug）分支</li>
</ul>
<p>这三种分支都属于临时性需要，使用完以后，应该删除，使得代码库的常设分支始终只有Master和Develop。</p>
<h3 id="四、功能分支"><a href="#四、功能分支" class="headerlink" title="四、功能分支"></a>四、功能分支</h3><p>接下来，一个个来看这三种”临时性分支”。<br>第一种是功能分支，它是为了开发某种特定功能，从Develop分支上面分出来的。开发完成后，要再并入Develop。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070507.png" alt=""></p>
<p>功能分支的名字，可以采用feature-*的形式命名。<br>创建一个功能分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b feature-x develop</div></pre></td></tr></table></figure></p>
<p>开发完成后，将功能分支合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff feature-x</div></pre></td></tr></table></figure></p>
<p>删除feature分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d feature-x</div></pre></td></tr></table></figure></p>
<h3 id="五、预发布分支"><a href="#五、预发布分支" class="headerlink" title="五、预发布分支"></a>五、预发布分支</h3><p>第二种是预发布分支，它是指发布正式版本之前（即合并到Master分支之前），我们可能需要有一个预发布的版本进行测试。<br>预发布分支是从Develop分支上面分出来的，预发布结束以后，必须合并进Develop和Master分支。它的命名，可以采用release-*的形式。<br>创建一个预发布分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b release-1.2 develop</div></pre></td></tr></table></figure></p>
<p>确认没有问题后，合并到master分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --no-ff release-1.2</div></pre></td></tr></table></figure></p>
<p>对合并生成的新节点，做一个标签<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git tag -a 1.2</div></pre></td></tr></table></figure></p>
<p>再合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff release-1.2</div></pre></td></tr></table></figure></p>
<p>最后，删除预发布分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d release-1.2</div></pre></td></tr></table></figure></p>
<h3 id="六、修补bug分支"><a href="#六、修补bug分支" class="headerlink" title="六、修补bug分支"></a>六、修补bug分支</h3><p>最后一种是修补bug分支。软件正式发布以后，难免会出现bug。这时就需要创建一个分支，进行bug修补。<br>修补bug分支是从Master分支上面分出来的。修补结束以后，再合并进Master和Develop分支。它的命名，可以采用fixbug-*的形式。</p>
<p><img src="http://image.beekka.com/blog/201207/bg2012070508.png" alt=""></p>
<p>创建一个修补bug分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b fixbug-0.1 master</div></pre></td></tr></table></figure></p>
<p>修补结束后，合并到master分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge --no-ff fixbug-0.1</div><div class="line">git tag -a 0.1.1</div></pre></td></tr></table></figure></p>
<p>再合并到develop分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout develop</div><div class="line">git merge --no-ff fixbug-0.1</div></pre></td></tr></table></figure></p>
<p>最后，删除”修补bug分支”：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d fixbug-0.1</div></pre></td></tr></table></figure></p>
<p>　　<br>（完）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你应该知道的BuildConfig]]></title>
      <url>http://yoursite.com/2016/12/26/%E4%BD%A0%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84BuildConfig/</url>
      <content type="html"><![CDATA[<p>可能有些人不知道BuildConfig是何物，尤其是初学者，那么试想我们每次编译Release版本时，由于Debug和Relaease环境下配置有所不同，打包前总是要禁用调试Log，修改服务器Host从测试服到正式服等等一系列操作，一般的做法是在编译Release版本前修改相应的配置，开发时再修改回Debug环境。很繁琐有没有？</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<p>在编译时，Android Studio 会生成一个名为 BuildConfig 的类，它包含了一些编译时使用到的常量指。生成的BuildConfig文件内容如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildConfig</span> </span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true|false"</span>);</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String APPLICATION_ID = <span class="string">"xyz.facex.demo"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUILD_TYPE = <span class="string">"debug"</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FLAVOR = <span class="string">""</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VERSION_CODE = <span class="number">1</span>;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String VERSION_NAME = <span class="string">"1.0"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当编译Debug版本时,BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"true"</span>);</div></pre></td></tr></table></figure></p>
<p>当编译Release版本时，BuildConfig类中DEBUG变量如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = Boolean.parseBoolean(<span class="string">"false"</span>);</div></pre></td></tr></table></figure></p>
<p>是的，看到这里，我想你应该知道了。</p>
<p>现在我们举个栗子说明下，新建HttpHost类，用来获取服务器Host，我们将BuildConfig类中DEBUG变量赋值给HttpHost的DEBUG，然后我们通过判断HttpHost中DEBUG的值取到相应的Host，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpHost</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = BuildConfig.DEBUG;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST_TEST = <span class="string">"测试服务器地址"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HOST = <span class="string">"正式服务器地址"</span>;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据不同版本调用不同的HOST</div><div class="line">     * debug版本返回"测试服务器地址"</div><div class="line">     * release版本返回"正式服务器地址"</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getHost</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> DEBUG ? HOST_TEST : HOST;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>按照以上代码，我们在发布Release版本时无需修改一行代码，一个字<strong>爽</strong>！</p>
<blockquote>
<p>另外BuildConfig中的变量还支持自定义，有兴趣的可以自行Google。</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用高德地图模拟运动轨迹]]></title>
      <url>http://yoursite.com/2016/12/14/%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE%E6%A8%A1%E6%8B%9F%E8%BF%90%E5%8A%A8%E8%BD%A8%E8%BF%B9/</url>
      <content type="html"><![CDATA[<p>最近在做一款跑步机的APP，需求是在地图上选定起点和终点，然后根据跑步机上设定的速度模拟用户在地图上沿着起点至终点运动。一般的地图开发，实时位置可通过手机GPS获取，然而本项目用户在跑步机上运动，用户在地图上的位置要根据跑步机设定的速度来模拟。对比了下百度，高德和腾讯地图，冲着高德地图的Demo和文档比较齐全，项目中选定高德地图作为地图开发。<br><a id="more"></a></p>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<ul>
<li><p>意外发现高德3D地图在12月9日更新了<strong>点平滑移动</strong>的api，细看之下非常符合本次需要，感谢高德开发人员，不然有得折腾了！</p>
</li>
<li><p>下文中的<strong>点</strong>指代用户在地图中的位置。</p>
</li>
</ul>
</blockquote>
<p>开撸之前，先上无码图。</p>
<p><img src="http://ohnwilkou.bkt.clouddn.com/SimulateRunning.gif" alt="SimulateRunning"></p>
<h3 id="1-获取轨迹点"><a href="#1-获取轨迹点" class="headerlink" title="1. 获取轨迹点"></a>1. 获取轨迹点</h3><p>首先为简单起见，我事先准备好了起点和终点的经纬度，由于是模拟跑步路径，我选用<strong>步行出行路线规划</strong>获取跑步轨迹。规划成功后我们在onWalkRouteSearched的回调WalkRouteResult中取得轨迹点，只不过返回的轨迹点是一段一段的，为迎合点平滑移动的api，需要每一段的steps合并成一个list。</p>
<h4 id="1-1-规划路径"><a href="#1-1-规划路径" class="headerlink" title="1.1 规划路径"></a>1.1 规划路径</h4><p>根据起点和重点，调用高德api规划路径。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getRoute</span><span class="params">()</span> </span>&#123;</div><div class="line">    RouteSearch routeSearch = <span class="keyword">new</span> RouteSearch(<span class="keyword">this</span>);</div><div class="line">    routeSearch.setRouteSearchListener(<span class="keyword">this</span>);</div><div class="line">    RouteSearch.FromAndTo fromAndTo = <span class="keyword">new</span> RouteSearch.FromAndTo(startPoint, endPoint);</div><div class="line">    RouteSearch.WalkRouteQuery query = <span class="keyword">new</span> RouteSearch.WalkRouteQuery(fromAndTo, RouteSearch.WalkDefault);</div><div class="line">    routeSearch.calculateWalkRouteAsyn(query);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="1-2-处理回调数据"><a href="#1-2-处理回调数据" class="headerlink" title="1.2 处理回调数据"></a>1.2 处理回调数据</h4><p>取出每一段点得经纬度，合并成一个list。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onWalkRouteSearched</span><span class="params">(WalkRouteResult walkRouteResult, <span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">    mLatLngs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">    mMap.clear();</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">1000</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (walkRouteResult != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths() != <span class="keyword">null</span> &amp;&amp; walkRouteResult.getPaths().size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            WalkPath walkPath = walkRouteResult.getPaths().get(<span class="number">0</span>);</div><div class="line">            mAllDistance = walkPath.getDistance();</div><div class="line">            List&lt;WalkStep&gt; walkSteps = walkPath.getSteps();</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; walkSteps.size(); j++) &#123;</div><div class="line">                List&lt;LatLonPoint&gt; latLonPoints = walkSteps.get(j).getPolyline();</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; latLonPoints.size(); k++) &#123;</div><div class="line">                    LatLonPoint latLonPoint = latLonPoints.get(k);</div><div class="line">                    mLatLngs.add(<span class="keyword">new</span> LatLng(latLonPoint.getLatitude(), latLonPoint.getLongitude()));</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">/**</span></div><div class="line">             * 在地图上显示规划路径</div><div class="line">            */</div><div class="line">            addPolylineInPlayGround();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-显示路径"><a href="#2-显示路径" class="headerlink" title="2. 显示路径"></a>2. 显示路径</h3><p>简单地在地图上显示路径</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addPolylineInPlayGround</span><span class="params">()</span> </span>&#123;</div><div class="line">    List&lt;LatLng&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">    mMap.addPolyline(<span class="keyword">new</span> PolylineOptions().addAll(list).width(<span class="number">10</span>).color(Color.RED));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     *  改变地图视口</div><div class="line">     */</div><div class="line">    LatLngBounds bounds = <span class="keyword">new</span> LatLngBounds(list.get(<span class="number">0</span>), list.get(list.size() - <span class="number">2</span>));</div><div class="line">    mMap.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, <span class="number">200</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-开始移跑步"><a href="#3-开始移跑步" class="headerlink" title="3. 开始移跑步"></a>3. 开始移跑步</h3><p>用户选择开始跑步时，地图中的点要根据跑步机上设定的速度模拟在地图中运动。根据高德地图<strong>点平滑移动</strong>开发文档，初始化一些数据和设置，开始移动点。高德已经为我们做好了处理，按我们设置的<strong>总移动时间</strong>从起点平滑地移动至终点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mPoints = <span class="keyword">new</span> ArrayList&lt;&gt;(mLatLngs);</div><div class="line">       mSmoothMoveMarker = <span class="keyword">new</span> SmoothMoveMarker(mMap);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的图标</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setDescriptor(BitmapDescriptorFactory.fromResource(R.drawable.ic_navigation_green_a700_24dp));</div><div class="line">       LatLng drivePoint = mPoints.get(<span class="number">0</span>);</div><div class="line">       Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">       mPoints.set(pair.first, drivePoint);</div><div class="line">       List&lt;LatLng&gt; subList = mPoints.subList(pair.first, mPoints.size());</div><div class="line">       <span class="comment">/**</span></div><div class="line">       * 设置滑动的轨迹左边点</div><div class="line">       */</div><div class="line">       mSmoothMoveMarker.setPoints(subList);</div><div class="line">       <span class="comment">/**</span></div><div class="line">        * 设置滑动的总时间</div><div class="line">        */</div><div class="line">       mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mAllDistance / mSpeed));</div><div class="line">       mSmoothMoveMarker.startSmoothMove();</div><div class="line">       mSmoothMoveMarker.setMoveListener(<span class="keyword">new</span> SmoothMoveMarker.MoveListener() &#123;</div><div class="line">           <span class="meta">@Override</span></div><div class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">double</span> v)</span> </span>&#123;</div><div class="line">               <span class="comment">/**</span></div><div class="line">                * 最后一次取到的值即为暂停时的数据，getIndex()方法取到的是当前list的下标,v为剩余距离</div><div class="line">                */</div><div class="line">               mPauseIndex = mSmoothMoveMarker.getIndex();</div><div class="line">               mDistanceRemain = v;</div><div class="line">           &#125;</div><div class="line">       &#125;);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>总移动时间=轨迹长度/运动速度</p>
</blockquote>
<h3 id="4-暂停跑步"><a href="#4-暂停跑步" class="headerlink" title="4. 暂停跑步"></a>4. 暂停跑步</h3><p>用户选择暂停跑步时，我们需要获取到暂停的剩余的轨迹长度和剩余的轨迹点。暂停时的数据已经在上一步取到了，这里只是停止点得移动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pauseRun</span><span class="params">()</span> </span>&#123;</div><div class="line">       mSmoothMoveMarker.stopMove();</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h3 id="5-继续跑步"><a href="#5-继续跑步" class="headerlink" title="5. 继续跑步"></a>5. 继续跑步</h3><p>用户选择选择继续跑步时，我们需要在原先暂停的位置继续移动点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">continueRun</span><span class="params">()</span> </span>&#123;</div><div class="line">        LatLng drivePoint = mPoints.get(mPauseIndex + <span class="number">1</span>);</div><div class="line">        Pair&lt;Integer, LatLng&gt; pair = SpatialRelationUtil.calShortestDistancePoint(mPoints, drivePoint);</div><div class="line">        mPoints.set(pair.first, drivePoint);</div><div class="line">        mPoints = mPoints.subList(pair.first, mPoints.size());</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置剩余的轨迹点</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setPoints(mPoints);</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 重新设置滑动时间</div><div class="line">         */</div><div class="line">        mSmoothMoveMarker.setTotalDuration((<span class="keyword">int</span>) (mDistanceRemain / mSpeed));</div><div class="line">        mSmoothMoveMarker.startSmoothMove();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<h3 id="6-结束跑步"><a href="#6-结束跑步" class="headerlink" title="6. 结束跑步"></a>6. 结束跑步</h3><p>当点滑动到达终点时，结束跑步。</p>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h3><p>通过以上步骤可以较好的实现需求，以上只是简单的记录实现步骤，具体的细节美化可以按照各自的需求处理。<br>项目Demo：<a href="https://github.com/facexxyz/ImitateRunning。" target="_blank" rel="external">https://github.com/facexxyz/ImitateRunning。</a><br>项目APK:<a href="https://www.pgyer.com/ImitateRunning" target="_blank" rel="external">https://www.pgyer.com/ImitateRunning</a></p>
<blockquote>
<p>参考文献：<a href="http://lbs.amap.com/api/android-sdk/guide/draw-on-map/smooth-move/" target="_blank" rel="external">高德地图点平滑移动api</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>http://yoursite.com/2016/12/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>项目中遇到这样的一个需求：分别需要对发送的数据和接受的数据做编码和解码处理，且不同的设备编码和解码方式不同。一般写法是根据不同的设备选择相应的编码和解码方式。但是这种方法耦合性高，不易维护，增加设备的支持就需要修改原先的代码，这容易在原本正确的代码中引入新的错误，这也违背了开闭原则。对于这种情况，一种较好的解决方式就是策略模式。</p>
<a id="more"></a>
<p><strong>转载请注明出处：<a href="http://www.facex.xyz" target="_blank" rel="external">www.facex.xyz</a>，如有发现错误或有其他更好的实现方式可与我联系。</strong></p>
<blockquote>
<p>开闭原则：软件中的对象（类、模块、函数等）应该对于扩展是开放的，但是对于修改是封闭的。</p>
</blockquote>
<h3 id="1-策略模式的定义"><a href="#1-策略模式的定义" class="headerlink" title="1. 策略模式的定义"></a>1. 策略模式的定义</h3><p>策略模式定义了一系列算法，并将每一个算法封装起来，而且使它们还可以相互替换。策略模式让算法独立于使用它的客户而存在。</p>
<h3 id="2-策略模式的使用场景"><a href="#2-策略模式的使用场景" class="headerlink" title="2. 策略模式的使用场景"></a>2. 策略模式的使用场景</h3><ul>
<li>针对同一问题的多种处理方式，仅仅是具体行为有差别时。</li>
<li>需要安全的封装多种同一类型的操作时。</li>
<li>出现同一抽象类有多个子类，而又需要使用if-else或者switch-case来选择具体子类时。</li>
</ul>
<h3 id="4-UML类图"><a href="#4-UML类图" class="headerlink" title="4. UML类图"></a>4. UML类图</h3><p><img src="http://ohnwilkou.bkt.clouddn.com/pattern_strategy.jpg" alt="策略模式"></p>
<hr>
<h3 id="5-重构步骤"><a href="#5-重构步骤" class="headerlink" title="5. 重构步骤"></a>5. 重构步骤</h3><ol>
<li><p>首先定义设备解码编码策略接口类：DeviceCodecStrategy，类中定义decode和encode两个虚拟方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义设备A编码解码策略实现类：DeviceAStrategy，该类实现DeviceCodecStrategy接口。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceAStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备A解码相关方法，这里将需要解码的信息-1</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * Author: www.facex.xyz</div><div class="line">         * 设备A编码相关方法，这里将需要解码的信息+1</div><div class="line">         */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>定义角色类：DeviceCodec</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceCodec</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> DeviceCodecStrategy mStrategy;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStrategy</span><span class="params">(DeviceCodecStrategy strategy)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.mStrategy = strategy;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.decode(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> mStrategy.encode(data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>使用策略模式</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    DeviceCodec deviceCodec = <span class="keyword">new</span> DeviceCodec();</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 设置解码编码策略</div><div class="line">     */</div><div class="line">    deviceCodec.setStrategy(<span class="keyword">new</span> DeviceAStrategy());</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 编码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A编码后："</span> + deviceCodec.encode(<span class="number">10</span>));</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Author: www.facex.xyz</div><div class="line">     * 解码</div><div class="line">     */</div><div class="line">    System.out.println(<span class="string">"设备A解码后："</span> + deviceCodec.decode(<span class="number">10</span>));</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p> 输出结果如下，符合预期：</p>
<blockquote>
<p>设备A编码后：11</p>
<p>设备A解码后：9</p>
</blockquote>
</li>
<li><p>现在我们要支持新的DeviceB设备，同DeviceA，定义设备B编码解码策略实现类：DeviceBStrategy，实现DeviceCodecStrategy接口，使用方式同DeviceA。</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeviceBStrategy</span> <span class="keyword">implements</span> <span class="title">DeviceCodecStrategy</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B解码相关方法，这里将需要解码的信息-2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data - <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</div><div class="line">      <span class="comment">/**</span></div><div class="line">       * Author: www.facex.xyz</div><div class="line">       * 设备B编码相关方法，这里将需要解码的信息+2</div><div class="line">       */</div><div class="line">        <span class="keyword">return</span> data + <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>使用策略模式重构代码后，隐藏了编码解码实现，同时可扩展性变强。以后新增加设备只需要实现DeviceCodecStrategy接口，重现decode和encode方法即可，不仅符合了开闭原则，而且逻辑性更强。</p>
<blockquote>
<p>参考文献：《Android源码设计模式解析与实战》</p>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
